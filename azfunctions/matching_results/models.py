from openai import BaseModel
from datetime import datetime
from enum import Enum
from uuid import UUID, uuid4
from typing import Optional

from pydantic import BaseModel, Field, model_validator
from typing import List



class FileType(str, Enum):
    CV = "CV"
    JD = "JD"
    
class MatchingResultsRequest(BaseModel):
    file_id: str
    file_type: FileType
    
class MatchingBaseModel(BaseModel):
    pass
    # add created_at and updated_at fields autogenerated with current datetime at the moment of creation
    # created_at: datetime = Field(default_factory=datetime.now)
    # updated_at: datetime = Field(default_factory=datetime.now)
    
    # model_config = ConfigDict(
    #     validate_assignment=True,
    # )
    
    # @model_validator(mode='after')
    # @classmethod
    # def update_updated_at(cls, values):
    #     values.updated_at = datetime.now()
    #     return values
    
    
class MatchingRequestBase(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    filename: str
    type: FileType
    url: str
    
class MatchingRequestMessage(MatchingRequestBase):
    pass

class MatchingRequestModel(MatchingBaseModel):
    id: UUID
    filename: str
    type: FileType
    url: str
    text: str


class FileModel(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    filename: str
    type: FileType
    url: str
    # text: str
    
class JD_Requirements(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    skills: List[str]
    experience: List[str]
    education: List[str]
    
    
class Candidate_Capabilities(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    skills: List[str]
    experience: List[str]
    education: List[str]
    
    
class CV_Match(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    skills_match: List[str]
    experience_match: List[str]
    education_match: List[str]
    gaps: List[str]
    
    
class MatchingResultModel(MatchingBaseModel):
    id: UUID = Field(default_factory=uuid4)
    user_id: str
    cv: FileModel
    jd: FileModel
    jd_requirements: JD_Requirements
    candidate_capabilities: Candidate_Capabilities
    cv_match: CV_Match
    overall_match_percentage: float
    
    # function to create model from json by creating nested models first
    @classmethod
    def from_json(cls, json_data):
        json_data['cv'] = FileModel(**json_data['cv'])
        json_data['jd'] = FileModel(**json_data['jd'])
        json_data['jd_requirements'] = JD_Requirements(**json_data['jd_requirements'])
        json_data['candidate_capabilities'] = Candidate_Capabilities(**json_data['candidate_capabilities'])
        json_data['cv_match'] = CV_Match(**json_data['cv_match'])
        return cls(**json_data)


class MatchingResultsResponse(BaseModel):
    results: List[MatchingResultModel]

    @classmethod
    def from_json(cls, list_of_dict):
        results = [MatchingResultModel.from_json(result) for result in list_of_dict]
        return cls(results=results)